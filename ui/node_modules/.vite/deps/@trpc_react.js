import {
  _setPrototypeOf,
  hashQueryKey,
  useInfiniteQuery,
  useMutation,
  useQuery
} from "./chunk-TN2HFBXG.js";
import "./chunk-WMIXMSGG.js";
import {
  __toESM,
  require_react
} from "./chunk-PC5MGJGW.js";

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

// node_modules/@babel/runtime/helpers/esm/objectSpread2.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}

// node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

// node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

// node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}

// node_modules/@babel/runtime/helpers/esm/inherits.js
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}

// node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}

// node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}

// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}

// node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}

// node_modules/@babel/runtime/helpers/esm/createSuper.js
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}

// node_modules/@babel/runtime/helpers/esm/isNativeFunction.js
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

// node_modules/@babel/runtime/helpers/esm/construct.js
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}

// node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}

// node_modules/@trpc/client/dist/TRPCClientError-09b8a26b.esm.js
var TRPCClientError = function(_Error) {
  _inherits(TRPCClientError2, _Error);
  var _super = _createSuper(TRPCClientError2);
  function TRPCClientError2(message, opts) {
    var _opts$cause, _opts$isDone, _opts$result, _opts$result2;
    var _this;
    _classCallCheck(this, TRPCClientError2);
    var cause = (_opts$cause = opts.cause) !== null && _opts$cause !== void 0 ? _opts$cause : opts.originalError;
    _this = _super.call(this, message, {
      cause
    });
    _this.originalError = void 0;
    _this.cause = void 0;
    _this.shape = void 0;
    _this.data = void 0;
    _this.isDone = void 0;
    _this.isDone = (_opts$isDone = opts.isDone) !== null && _opts$isDone !== void 0 ? _opts$isDone : false;
    _this.cause = _this.originalError = cause;
    _this.shape = (_opts$result = opts.result) === null || _opts$result === void 0 ? void 0 : _opts$result.error;
    _this.data = (_opts$result2 = opts.result) === null || _opts$result2 === void 0 ? void 0 : _opts$result2.error.data;
    _this.name = "TRPCClientError";
    Object.setPrototypeOf(_assertThisInitialized(_this), TRPCClientError2.prototype);
    return _this;
  }
  _createClass(TRPCClientError2, null, [{
    key: "from",
    value: function from(result) {
      var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!(result instanceof Error)) {
        var _message;
        return new TRPCClientError2((_message = result.error.message) !== null && _message !== void 0 ? _message : "", _objectSpread2(_objectSpread2({}, opts), {}, {
          cause: null,
          result
        }));
      }
      if (result.name === "TRPCClientError") {
        return result;
      }
      return new TRPCClientError2(result.message, _objectSpread2(_objectSpread2({}, opts), {}, {
        cause: result,
        result: null
      }));
    }
  }]);
  return TRPCClientError2;
}(_wrapNativeSuper(Error));

// node_modules/@trpc/client/dist/httpRequest-62c5cce4.esm.js
function transformRPCResponse(_ref) {
  var envelope = _ref.envelope, runtime = _ref.runtime;
  if ("error" in envelope) {
    return TRPCClientError.from(_objectSpread2(_objectSpread2({}, envelope), {}, {
      error: runtime.transformer.deserialize(envelope.error)
    }));
  }
  if (envelope.result.type === "data") {
    return _objectSpread2(_objectSpread2({}, envelope.result), {}, {
      data: runtime.transformer.deserialize(envelope.result.data)
    });
  }
  return envelope.result;
}
var TRPCAbortError = function(_Error) {
  _inherits(TRPCAbortError2, _Error);
  var _super = _createSuper(TRPCAbortError2);
  function TRPCAbortError2() {
    var _this;
    _classCallCheck(this, TRPCAbortError2);
    _this = _super.call(this, "The operation was aborted.");
    _this.name = "TRPCAbortError";
    Object.setPrototypeOf(_assertThisInitialized(_this), TRPCAbortError2.prototype);
    return _this;
  }
  return _createClass(TRPCAbortError2);
}(_wrapNativeSuper(Error));
function arrayToDict(array) {
  var dict = {};
  for (var index = 0; index < array.length; index++) {
    var element = array[index];
    dict[index] = element;
  }
  return dict;
}
function httpRequest(props) {
  var type = props.type, rt = props.runtime, path = props.path;
  var ac = rt.AbortController ? new rt.AbortController() : null;
  var method = {
    query: "GET",
    mutation: "POST",
    subscription: "PATCH"
  };
  var input = "input" in props ? rt.transformer.serialize(props.input) : arrayToDict(props.inputs.map(function(_input) {
    return rt.transformer.serialize(_input);
  }));
  function getUrl() {
    var url = props.url + "/" + path;
    var queryParts = [];
    if ("inputs" in props) {
      queryParts.push("batch=1");
    }
    if (type === "query" && input !== void 0) {
      queryParts.push("input=".concat(encodeURIComponent(JSON.stringify(input))));
    }
    if (queryParts.length) {
      url += "?" + queryParts.join("&");
    }
    return url;
  }
  function getBody() {
    if (type === "query") {
      return void 0;
    }
    return input !== void 0 ? JSON.stringify(input) : void 0;
  }
  var promise = new Promise(function(resolve, reject) {
    var url = getUrl();
    Promise.resolve(rt.headers()).then(function(rawHeaders) {
      var headers = {
        "content-type": "application/json"
      };
      for (var key in rawHeaders) {
        var header = rawHeaders[key];
        if (header !== void 0) {
          if (Array.isArray(header)) {
            headers[key] = header.join(",");
          } else {
            headers[key] = header;
          }
        }
      }
      return rt.fetch(url, {
        method: method[type],
        signal: ac === null || ac === void 0 ? void 0 : ac.signal,
        body: getBody(),
        headers
      });
    }).then(function(res) {
      return res.json();
    }).then(function(json) {
      resolve(json);
    }).catch(reject);
  });
  var cancel = function cancel2() {
    ac === null || ac === void 0 ? void 0 : ac.abort();
  };
  return {
    promise,
    cancel
  };
}

// node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}

// node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}

// node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      var F = function F2() {
      };
      return {
        s: F,
        n: function n() {
          if (i >= o.length)
            return {
              done: true
            };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }
  };
}

// node_modules/@trpc/client/links/httpBatchLink/dist/trpc-client-links-httpBatchLink.esm.js
function dataLoader(fetchMany, opts) {
  var batch = null;
  var dispatchTimer = null;
  var destroyTimerAndBatch = function destroyTimerAndBatch2() {
    clearTimeout(dispatchTimer);
    dispatchTimer = null;
    batch = null;
  };
  function dispatch() {
    var batchCopy = batch;
    destroyTimerAndBatch();
    var _fetchMany = fetchMany(batchCopy.items.map(function(v) {
      return v.key;
    })), promise = _fetchMany.promise, cancel = _fetchMany.cancel;
    batchCopy.cancel = cancel;
    promise.then(function(result) {
      for (var i = 0; i < result.length; i++) {
        var _value = result[i];
        batchCopy.items[i].resolve(_value);
      }
    }).catch(function(cause) {
      var _iterator = _createForOfIteratorHelper(batchCopy.items), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var item = _step.value;
          item.reject(cause);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    });
  }
  function load(key) {
    var batchItem = {
      cancelled: false,
      key
    };
    if (!batch) {
      batch = {
        items: [],
        cancel: function cancel2() {
          destroyTimerAndBatch();
        }
      };
    }
    var thisBatch = batch;
    var dispatchImmediately = false;
    var promise = new Promise(function(resolve, reject) {
      var item = batchItem;
      item.reject = reject;
      item.resolve = resolve;
      thisBatch.items.push(item);
      if (typeof (opts === null || opts === void 0 ? void 0 : opts.maxBatchSize) !== "undefined" && thisBatch.items.length >= opts.maxBatchSize) {
        dispatchImmediately = true;
      }
    });
    var cancel = function cancel2() {
      batchItem.cancelled = true;
      if (thisBatch.items.some(function(item) {
        return !item.cancelled;
      })) {
        return;
      }
      thisBatch.cancel();
    };
    if (dispatchImmediately) {
      dispatch();
    } else if (!dispatchTimer) {
      dispatchTimer = setTimeout(dispatch);
    }
    return {
      promise,
      cancel
    };
  }
  return {
    load
  };
}
function httpBatchLink(opts) {
  var url = opts.url, maxBatchSize = opts.maxBatchSize;
  return function(runtime) {
    var fetcher = function fetcher2(type) {
      return function(keyInputPairs) {
        var path = keyInputPairs.map(function(op) {
          return op.path;
        }).join(",");
        var inputs = keyInputPairs.map(function(op) {
          return op.input;
        });
        var _httpRequest = httpRequest({
          url,
          inputs,
          path,
          runtime,
          type
        }), promise = _httpRequest.promise, cancel = _httpRequest.cancel;
        return {
          promise: promise.then(function(res) {
            if (!Array.isArray(res)) {
              return keyInputPairs.map(function() {
                return res;
              });
            }
            return res;
          }),
          cancel
        };
      };
    };
    var query = dataLoader(fetcher("query"), {
      maxBatchSize
    });
    var mutation = dataLoader(fetcher("mutation"), {
      maxBatchSize
    });
    var subscription = dataLoader(fetcher("subscription"), {
      maxBatchSize
    });
    var loaders = {
      query,
      subscription,
      mutation
    };
    return function(_ref) {
      var op = _ref.op, prev = _ref.prev, onDestroy = _ref.onDestroy;
      var loader = loaders[op.type];
      var _loader$load = loader.load(op), promise = _loader$load.promise, cancel = _loader$load.cancel;
      var isDone = false;
      var prevOnce = function prevOnce2(result) {
        if (isDone) {
          return;
        }
        isDone = true;
        prev(result);
      };
      onDestroy(function() {
        prevOnce(TRPCClientError.from(new TRPCAbortError(), {
          isDone: true
        }));
        cancel();
      });
      promise.then(function(envelope) {
        prevOnce(transformRPCResponse({
          envelope,
          runtime
        }));
      }).catch(function(cause) {
        prevOnce(TRPCClientError.from(cause));
      });
    };
  };
}

// node_modules/@trpc/client/dist/trpc-client.esm.js
function getWindow() {
  if (typeof window !== "undefined") {
    return window;
  }
  return global;
}
function getAbortController(ac) {
  var win = getWindow();
  return ac || win.AbortController || null;
}
function getFetch(f) {
  if (f) {
    return f;
  }
  var win = getWindow();
  if (win.fetch) {
    return typeof win.fetch.bind === "function" ? win.fetch.bind(win) : win.fetch;
  }
  throw new Error("No fetch implementation found");
}
function observable() {
  var listeners = [];
  var value = null;
  return {
    subscribe: function subscribe(callbacks) {
      var listener = {
        callbacks,
        unsubscribe: function unsubscribe() {
          var index = listeners.indexOf(listener);
          if (index !== -1) {
            var _listener$callbacks$o, _listener$callbacks;
            listeners.splice(index, 1);
            (_listener$callbacks$o = (_listener$callbacks = listener.callbacks).onDone) === null || _listener$callbacks$o === void 0 ? void 0 : _listener$callbacks$o.call(_listener$callbacks);
          }
        }
      };
      listeners.push(listener);
      return function() {
        listener.unsubscribe();
      };
    },
    next: function next(newValue) {
      var oldValue = value;
      value = newValue;
      if (oldValue !== newValue) {
        var _iterator = _createForOfIteratorHelper(listeners), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var _listener$callbacks$o2, _listener$callbacks2;
            var listener = _step.value;
            (_listener$callbacks$o2 = (_listener$callbacks2 = listener.callbacks).onNext) === null || _listener$callbacks$o2 === void 0 ? void 0 : _listener$callbacks$o2.call(_listener$callbacks2, newValue);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    },
    done: function done() {
      while (listeners.length) {
        var _listener$callbacks$o3, _listener$callbacks3;
        var listener = listeners.pop();
        listener === null || listener === void 0 ? void 0 : (_listener$callbacks$o3 = (_listener$callbacks3 = listener.callbacks).onDone) === null || _listener$callbacks$o3 === void 0 ? void 0 : _listener$callbacks$o3.call(_listener$callbacks3);
        listener === null || listener === void 0 ? void 0 : listener.unsubscribe();
      }
    },
    error: function(_error) {
      function error(_x) {
        return _error.apply(this, arguments);
      }
      error.toString = function() {
        return _error.toString();
      };
      return error;
    }(function(error) {
      var _iterator2 = _createForOfIteratorHelper(listeners), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var _listener$callbacks$o4, _listener$callbacks4;
          var listener = _step2.value;
          (_listener$callbacks$o4 = (_listener$callbacks4 = listener.callbacks).onError) === null || _listener$callbacks$o4 === void 0 ? void 0 : _listener$callbacks$o4.call(_listener$callbacks4, error);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    })
  };
}
function observableSubject(initialValue) {
  var $obs = observable();
  var value = initialValue;
  $obs.next(initialValue);
  return _objectSpread2(_objectSpread2({}, $obs), {}, {
    next: function next(v) {
      value = v;
      $obs.next(v);
    },
    get: function get() {
      return value;
    }
  });
}
function executeChain(opts) {
  var $result = observableSubject(null);
  var updateResult = function updateResult2(result) {
    if (result instanceof Error) {
      $result.error(result);
      if (result.isDone) {
        $result.done();
      }
    } else {
      $result.next(result);
    }
  };
  function walk(_ref) {
    var index = _ref.index, op = _ref.op, stack = _ref.stack;
    var link = opts.links[index];
    var prev = index === 0 ? function(value) {
      return updateResult(value);
    } : stack[index - 1];
    link({
      op,
      prev,
      next: function next(op2, prevOp) {
        var prevStack = stack.slice();
        prevStack[index] = prevOp;
        walk({
          index: index + 1,
          op: op2,
          stack: prevStack
        });
      },
      onDestroy: function onDestroy(callback) {
        $result.subscribe({
          onDone: function onDone() {
            callback();
          }
        });
      }
    });
  }
  walk({
    index: 0,
    op: opts.op,
    stack: []
  });
  return $result;
}
var idCounter = 0;
function getRequestId() {
  return ++idCounter;
}
var TRPCClient = function() {
  function TRPCClient2(opts) {
    var _this = this;
    _classCallCheck(this, TRPCClient2);
    this.links = void 0;
    this.runtime = void 0;
    var transformer = opts.transformer ? "input" in opts.transformer ? {
      serialize: opts.transformer.input.serialize,
      deserialize: opts.transformer.output.deserialize
    } : opts.transformer : {
      serialize: function serialize(data) {
        return data;
      },
      deserialize: function deserialize(data) {
        return data;
      }
    };
    var _fetch = getFetch(opts === null || opts === void 0 ? void 0 : opts.fetch);
    var AC = getAbortController(opts === null || opts === void 0 ? void 0 : opts.AbortController);
    function getHeadersFn() {
      if (opts.headers) {
        var headers = opts.headers;
        return typeof headers === "function" ? headers : function() {
          return headers;
        };
      }
      return function() {
        return {};
      };
    }
    this.runtime = {
      transformer,
      AbortController: AC,
      fetch: _fetch,
      headers: getHeadersFn()
    };
    if ("links" in opts) {
      this.links = opts.links.map(function(link) {
        return link(_this.runtime);
      });
    } else {
      this.links = [httpBatchLink({
        url: opts.url
      })(this.runtime)];
    }
  }
  _createClass(TRPCClient2, [{
    key: "$request",
    value: function $request(_ref) {
      var type = _ref.type, input = _ref.input, path = _ref.path, _ref$context = _ref.context, context = _ref$context === void 0 ? {} : _ref$context;
      var $result = executeChain({
        links: this.links,
        op: {
          id: getRequestId(),
          type,
          path,
          input,
          context
        }
      });
      return $result;
    }
  }, {
    key: "requestAsPromise",
    value: function requestAsPromise(opts) {
      var $result = this.$request(opts);
      var promise = new Promise(function(resolve, reject) {
        var res = $result.get();
        if ((res === null || res === void 0 ? void 0 : res.type) === "data") {
          resolve(res.data);
          $result.done();
          return;
        }
        $result.subscribe({
          onNext: function onNext(result) {
            if ((result === null || result === void 0 ? void 0 : result.type) !== "data") {
              return;
            }
            resolve(result.data);
            $result.done();
          },
          onError: function onError(err) {
            reject(err);
            $result.done();
          },
          onDone: function onDone() {
            reject(TRPCClientError.from(new TRPCAbortError()));
          }
        });
      });
      promise.cancel = function() {
        $result.done();
      };
      return promise;
    }
  }, {
    key: "query",
    value: function query(path) {
      var _args$;
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      var context = (_args$ = args[1]) === null || _args$ === void 0 ? void 0 : _args$.context;
      return this.requestAsPromise({
        type: "query",
        path,
        input: args[0],
        context
      });
    }
  }, {
    key: "mutation",
    value: function mutation(path) {
      var _args$2;
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      var context = (_args$2 = args[1]) === null || _args$2 === void 0 ? void 0 : _args$2.context;
      return this.requestAsPromise({
        type: "mutation",
        path,
        input: args[0],
        context
      });
    }
  }, {
    key: "subscription",
    value: function subscription(path, input, opts) {
      var $res = this.$request({
        type: "subscription",
        path,
        input,
        context: opts.context
      });
      $res.subscribe({
        onNext: function onNext(output) {
          if (output) {
            var _opts$onNext;
            (_opts$onNext = opts.onNext) === null || _opts$onNext === void 0 ? void 0 : _opts$onNext.call(opts, output);
          }
        },
        onError: function onError(err) {
          var _opts$onError;
          (_opts$onError = opts.onError) === null || _opts$onError === void 0 ? void 0 : _opts$onError.call(opts, err);
        },
        onDone: opts.onDone
      });
      return function() {
        $res.done();
      };
    }
  }]);
  return TRPCClient2;
}();
function createTRPCClient(opts) {
  return new TRPCClient(opts);
}

// node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}

// node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}

// node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// node_modules/@babel/runtime/helpers/esm/toConsumableArray.js
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

// node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}

// node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}

// node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// node_modules/@babel/runtime/helpers/esm/slicedToArray.js
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

// node_modules/@trpc/react/dist/trpc-react.esm.js
var import_react = __toESM(require_react());
var TRPCContext = (0, import_react.createContext)(null);
function getClientArgs(pathAndInput, opts) {
  var _pathAndInput = _slicedToArray(pathAndInput, 2), path = _pathAndInput[0], input = _pathAndInput[1];
  return [path, input, opts];
}
function createReactQueryHooks() {
  var Context = TRPCContext;
  function createClient(opts) {
    return createTRPCClient(opts);
  }
  function TRPCProvider(props) {
    var client = props.client, queryClient = props.queryClient, ssrContext = props.ssrContext;
    var _useState = (0, import_react.useState)(props.ssrState || (props.isPrepass ? "prepass" : false)), _useState2 = _slicedToArray(_useState, 2), ssrState = _useState2[0], setSSRState = _useState2[1];
    (0, import_react.useEffect)(function() {
      setSSRState(function(state) {
        return state ? "mounted" : false;
      });
    }, []);
    return import_react.default.createElement(Context.Provider, {
      value: {
        queryClient,
        client,
        isPrepass: ssrState === "prepass",
        ssrContext: ssrContext || null,
        ssrState,
        fetchQuery: (0, import_react.useCallback)(function(pathAndInput, opts) {
          return queryClient.fetchQuery(pathAndInput, function() {
            var _ref;
            return (_ref = client).query.apply(_ref, _toConsumableArray(getClientArgs(pathAndInput, opts)));
          }, opts);
        }, [client, queryClient]),
        fetchInfiniteQuery: (0, import_react.useCallback)(function(pathAndInput, opts) {
          return queryClient.fetchInfiniteQuery(pathAndInput, function(_ref2) {
            var _ref3;
            var pageParam = _ref2.pageParam;
            var _pathAndInput2 = _slicedToArray(pathAndInput, 2), path = _pathAndInput2[0], input = _pathAndInput2[1];
            var actualInput = _objectSpread2(_objectSpread2({}, input), {}, {
              cursor: pageParam
            });
            return (_ref3 = client).query.apply(_ref3, _toConsumableArray(getClientArgs([path, actualInput], opts)));
          }, opts);
        }, [client, queryClient]),
        prefetchQuery: (0, import_react.useCallback)(function(pathAndInput, opts) {
          return queryClient.prefetchQuery(pathAndInput, function() {
            var _ref4;
            return (_ref4 = client).query.apply(_ref4, _toConsumableArray(getClientArgs(pathAndInput, opts)));
          }, opts);
        }, [client, queryClient]),
        prefetchInfiniteQuery: (0, import_react.useCallback)(function(pathAndInput, opts) {
          return queryClient.prefetchInfiniteQuery(pathAndInput, function(_ref5) {
            var _ref6;
            var pageParam = _ref5.pageParam;
            var _pathAndInput3 = _slicedToArray(pathAndInput, 2), path = _pathAndInput3[0], input = _pathAndInput3[1];
            var actualInput = _objectSpread2(_objectSpread2({}, input), {}, {
              cursor: pageParam
            });
            return (_ref6 = client).query.apply(_ref6, _toConsumableArray(getClientArgs([path, actualInput], opts)));
          }, opts);
        }, [client, queryClient]),
        invalidateQuery: (0, import_react.useCallback)(function() {
          return queryClient.invalidateQueries.apply(queryClient, arguments);
        }, [queryClient]),
        invalidateQueries: (0, import_react.useCallback)(function() {
          return queryClient.invalidateQueries.apply(queryClient, arguments);
        }, [queryClient]),
        refetchQueries: (0, import_react.useCallback)(function() {
          return queryClient.refetchQueries.apply(queryClient, arguments);
        }, [queryClient]),
        cancelQuery: (0, import_react.useCallback)(function(pathAndInput) {
          return queryClient.cancelQueries(pathAndInput);
        }, [queryClient]),
        setQueryData: (0, import_react.useCallback)(function() {
          return queryClient.setQueryData.apply(queryClient, arguments);
        }, [queryClient]),
        getQueryData: (0, import_react.useCallback)(function() {
          return queryClient.getQueryData.apply(queryClient, arguments);
        }, [queryClient]),
        setInfiniteQueryData: (0, import_react.useCallback)(function() {
          return queryClient.setQueryData.apply(queryClient, arguments);
        }, [queryClient]),
        getInfiniteQueryData: (0, import_react.useCallback)(function() {
          return queryClient.getQueryData.apply(queryClient, arguments);
        }, [queryClient])
      }
    }, props.children);
  }
  function useContext() {
    return import_react.default.useContext(Context);
  }
  function useSSRQueryOptionsIfNeeded(pathAndInput, opts) {
    var _queryClient$getQuery;
    var _useContext = useContext(), queryClient = _useContext.queryClient, ssrState = _useContext.ssrState;
    return ssrState && ssrState !== "mounted" && ((_queryClient$getQuery = queryClient.getQueryCache().find(pathAndInput)) === null || _queryClient$getQuery === void 0 ? void 0 : _queryClient$getQuery.state.status) === "error" ? _objectSpread2({
      retryOnMount: false
    }, opts) : opts;
  }
  function useQuery$1(pathAndInput, opts) {
    var _useContext2 = useContext(), client = _useContext2.client, isPrepass = _useContext2.isPrepass, queryClient = _useContext2.queryClient, prefetchQuery = _useContext2.prefetchQuery;
    if (typeof window === "undefined" && isPrepass && (opts === null || opts === void 0 ? void 0 : opts.ssr) !== false && (opts === null || opts === void 0 ? void 0 : opts.enabled) !== false && !queryClient.getQueryCache().find(pathAndInput)) {
      prefetchQuery(pathAndInput, opts);
    }
    var actualOpts = useSSRQueryOptionsIfNeeded(pathAndInput, opts);
    return useQuery(pathAndInput, function() {
      var _ref7;
      return (_ref7 = client).query.apply(_ref7, _toConsumableArray(getClientArgs(pathAndInput, actualOpts)));
    }, actualOpts);
  }
  function useMutation$1(path, opts) {
    var _useContext3 = useContext(), client = _useContext3.client;
    return useMutation(function(input) {
      var actualPath = Array.isArray(path) ? path[0] : path;
      return client.mutation(actualPath, input, opts);
    }, opts);
  }
  function useSubscription(pathAndInput, opts) {
    var _opts$enabled;
    var enabled = (_opts$enabled = opts === null || opts === void 0 ? void 0 : opts.enabled) !== null && _opts$enabled !== void 0 ? _opts$enabled : true;
    var queryKey = hashQueryKey(pathAndInput);
    var _useContext4 = useContext(), client = _useContext4.client;
    return (0, import_react.useEffect)(function() {
      if (!enabled) {
        return;
      }
      var _pathAndInput4 = _slicedToArray(pathAndInput, 2), path = _pathAndInput4[0], input = _pathAndInput4[1];
      var isStopped = false;
      var unsub = client.subscription(path, input !== null && input !== void 0 ? input : void 0, {
        onError: function onError(err) {
          if (!isStopped) {
            var _opts$onError;
            (_opts$onError = opts.onError) === null || _opts$onError === void 0 ? void 0 : _opts$onError.call(opts, err);
          }
        },
        onNext: function onNext(res) {
          if (res.type === "data" && !isStopped) {
            opts.onNext(res.data);
          }
        }
      });
      return function() {
        isStopped = true;
        unsub();
      };
    }, [queryKey, enabled]);
  }
  function useInfiniteQuery$1(pathAndInput, opts) {
    var _pathAndInput5 = _slicedToArray(pathAndInput, 2), path = _pathAndInput5[0], input = _pathAndInput5[1];
    var _useContext5 = useContext(), client = _useContext5.client, isPrepass = _useContext5.isPrepass, prefetchInfiniteQuery = _useContext5.prefetchInfiniteQuery, queryClient = _useContext5.queryClient;
    if (typeof window === "undefined" && isPrepass && (opts === null || opts === void 0 ? void 0 : opts.ssr) !== false && (opts === null || opts === void 0 ? void 0 : opts.enabled) !== false && !queryClient.getQueryCache().find(pathAndInput)) {
      prefetchInfiniteQuery(pathAndInput, opts);
    }
    var actualOpts = useSSRQueryOptionsIfNeeded(pathAndInput, opts);
    return useInfiniteQuery(pathAndInput, function(_ref8) {
      var _ref9, _ref10;
      var pageParam = _ref8.pageParam;
      var actualInput = _objectSpread2(_objectSpread2({}, (_ref9 = input) !== null && _ref9 !== void 0 ? _ref9 : {}), {}, {
        cursor: pageParam
      });
      return (_ref10 = client).query.apply(_ref10, _toConsumableArray(getClientArgs([path, actualInput], actualOpts)));
    }, actualOpts);
  }
  function useDehydratedState(client, trpcState) {
    var transformed = (0, import_react.useMemo)(function() {
      if (!trpcState) {
        return trpcState;
      }
      return client.runtime.transformer.deserialize(trpcState);
    }, [client, trpcState]);
    return transformed;
  }
  return {
    Provider: TRPCProvider,
    createClient,
    useContext,
    useQuery: useQuery$1,
    useMutation: useMutation$1,
    useSubscription,
    useDehydratedState,
    useInfiniteQuery: useInfiniteQuery$1
  };
}
export {
  TRPCAbortError,
  TRPCClientError,
  createReactQueryHooks,
  createTRPCClient,
  getFetch,
  transformRPCResponse
};
//# sourceMappingURL=@trpc_react.js.map
